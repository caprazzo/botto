package botto.xmpp.service.dispatcher;

import botto.xmpp.annotations.PacketOutput;
import botto.xmpp.engine.BotConnection;
import botto.xmpp.service.AbstractBot;
import botto.xmpp.service.Bot;
import net.caprazzi.reusables.common.Managed;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xmpp.packet.Packet;

public class DispatcherService implements Managed {

    private final static Logger Log = LoggerFactory.getLogger(DispatcherService.class);

    private final IncomingPacketDispatcher incomingDispatcher;
    private final OutgoingPacketDispatcher outgoingDispatcher;

    public DispatcherService() {
        outgoingDispatcher = new OutgoingPacketDispatcher();
        incomingDispatcher = new IncomingPacketDispatcher(outgoingDispatcher);
    }

    public synchronized void removeConnection(AbstractBot bot, BotConnection connection) {
       // TODO: also use connection when removing
       incomingDispatcher.removeRoute(bot);
       outgoingDispatcher.removeRoute(bot);
    }

    public synchronized void addConnection(final AbstractBot bot, final BotConnection connection) {
        // capture messages coming from this connection and put them to the incoming dispatcher
        connection.setConnectionPacketListener(new BotConnection.ConnectionPacketListener() {
            @Override
            public void onPacket(Packet packet) {
                incomingDispatcher.dispatch(new PacketEnvelope<BotConnection>(connection, packet));
            }
        });

        // route incoming packets to this bot.
        // TODO: can this be done with a table instead of scanning all filters?
        incomingDispatcher.addRoute(new PacketEnvelopeFilter<BotConnection>() {
            @Override
            public boolean accept(PacketEnvelope<BotConnection> packet) {
                return packet.getLabel().equals(connection);
            }
        }, bot);

        // route relevant outgoing packets to this connection
        outgoingDispatcher.addRoute(new PacketEnvelopeFilter<Bot>() {
            @Override
            public boolean accept(PacketEnvelope<Bot> packet) {
                return packet.getLabel().equals(bot);
            }
        }, connection);

        // route packets generated by this bot to the incoming dispatcher
        bot.setPacketOutput(new PacketOutput() {
            @Override
            public void send(Packet packet) {
                outgoingDispatcher.dispatch(new PacketEnvelope<Bot>(bot, packet));
            }
        });
    }

    /*
    public void addComponentBot(final AbstractBot bot, final NodeFilter nodeFilter, final PacketSource source, PacketOutput out) {
        incomingDispatcher.addRoute(new PacketEnvelopeFilter<PacketSource>() {
            @Override
            public boolean accept(PacketEnvelope<PacketSource> envelope) {
                return (envelope.getLabel().equals(source)
                    && nodeFilter.accept(envelope.getPacket().getTo().getNode()));
            }
        }, bot);

        outgoingDispatcher.addRoute(new PacketEnvelopeFilter<Bot>() {
            @Override
            public boolean accept(PacketEnvelope<Bot> packet) {
                return packet.getLabel().equals(bot);
            }
        }, out);

        // explicit packet output given to bots for sending via output.send
        bot.setPacketOutput(new PacketOutput() {
            @Override
            public void send(Packet packet) {
                outgoingDispatcher.dispatch(new PacketEnvelope<Bot>(bot, packet));
            }
        });
    }



    public void addNodeBot(final AbstractBot bot, final PacketSource source, final PacketOutput output) {


        source.setPacketSourceListener(new PacketSource.PacketSourceListener() {
            @Override
            public void receive(Packet packet) {
                incomingDispatcher.dispatch(new PacketEnvelope<PacketSource>(source, packet));
            }
        });

        // setup incoming messages to be routed to this bot
        incomingDispatcher.addRoute(new PacketEnvelopeFilter<PacketSource>() {
            @Override
            public boolean accept(PacketEnvelope<PacketSource> packet) {
                return packet.getLabel().equals(source);
            }
        }, bot);

        // setup outgoing messages to be handled by this bot session
        outgoingDispatcher.addRoute(new PacketEnvelopeFilter<Bot>() {
            @Override
            public boolean accept(PacketEnvelope<Bot> packet) {
                return packet.getLabel().equals(bot);
            }
        }, output);

        // explicit packet output given to bots for sending via output.send
        bot.setPacketOutput(new PacketOutput() {
            @Override
            public void send(Packet packet) {
                outgoingDispatcher.dispatch(new PacketEnvelope<Bot>(bot, packet));
            }
        });
    }
    */

    @Override
    public void start() {
        Log.info("Starting");
        outgoingDispatcher.start();
        incomingDispatcher.start();
        Log.info("Started");
    }

    @Override
    public void stop() {
        Log.info("Shutdown starting");
        incomingDispatcher.stop();
        outgoingDispatcher.stop();
        Log.info("Shutdown complete");
    }



}
